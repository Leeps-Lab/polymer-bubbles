<!-- lots of this is stolen from https://www.html5canvastutorials.com/labs/html5-canvas-graphing-an-equation/ -->

<link
    rel="import"
    href="https://polygit.org/polymer+^1.4.0/webcomponentsjs+^0.7.0/components/polymer/polymer.html">

<script src="colors.js"></script>

<dom-module id='bubbles-graph'>
<template>
    <canvas id='canvas' width='600' height='300'></canvas>
</template>
<script>
    Polymer({
        is: 'bubbles-graph',
        properties: {
            maxPayoff: {
                type: Number,
            },
            otherDecisions: {
                type: Array,
            },
            payoffFunction: {
                type: Object,
                value: function() {
                    return function() {
                        throw "payoff function not implemented";
                    };
                },
            },
        },
        observers: [
            '_redrawGraph(otherDecisions)',
        ],
        ready() {
            this.canvas = this.$.canvas;
            this.width = this.canvas.width;
            this.height = this.canvas.height;

            this.xMin = -0.06;
            this.xMax = 1.02;
            this.xRange = this.xMax - this.xMin;
            this.yMin = 0 - this.maxPayoff * 0.1;
            this.yMax = this.maxPayoff * 1.05;
            this.yRange = this.yMax - this.yMin;

            this.xScale = this.width / this.xRange;
            this.yScale = this.height / this.yRange;

            this.ctx = this.canvas.getContext('2d');

            this._redrawGraph();
        },
        _redrawGraph() {
            if (!this.ctx) {
                return;
            }

            let start = performance.now();
            this.ctx.clearRect(0, 0, this.width, this.height);
            this._drawXAxis();
            this._drawYAxis();
            this._drawPayoffLandscape();
            this._drawOthersBubbles();
            console.log(performance.now() - start);
        },
        _transformContext() {
            // changes bounds and scale of context so that x goes from xmin to xmax
            // and y goes from ymin to ymax
            this.ctx.scale(this.xScale, -this.yScale);
            this.ctx.translate(-this.xMin, -this.yMax)
        },
        _drawPayoffLandscape() {
            const ctx = this.ctx;

            const payoffFunction = this.get('payoffFunction');
            const otherDecisions = this.get('otherDecisions');

            ctx.save();
            ctx.save();
            this._transformContext();
            ctx.beginPath();

            const numSamples = this.width;
            const interval = this.xMax / numSamples;
            ctx.moveTo(0, payoffFunction(0, otherDecisions));
            for(let x = 0 + interval; x < 1; x += interval) {
                const y = payoffFunction(x, otherDecisions);
                ctx.lineTo(x, y);
            }

            ctx.restore();
            ctx.lineJoin = 'round';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
        },
        _drawOthersBubbles() {
            const ctx = this.ctx;

            const payoffFunction = this.get('payoffFunction');
            const otherDecisions = this.get('otherDecisions');

            ctx.save();

            const radius = 8;
            for(let i = 0; i < otherDecisions.length; i++) {
                ctx.beginPath();
                // we can't use transformContext because scaling contexts doesn't play nice with arc
                // so just manually transform x and y positions
                const x = (otherDecisions[i] - this.xMin) * this.xScale;
                const y = (this.yMax - 0) * this.yScale;
                ctx.arc(x, y, radius, 0, 2 * Math.PI);

                ctx.lineWidth = 2;
                ctx.strokeStyle = OTHER_COLORS[i];
                ctx.stroke();
            }

            ctx.restore();
        },
        _drawXAxis() {
            const ctx = this.ctx;
            ctx.save();

            ctx.save();
            ctx.beginPath();
            this._transformContext();
            ctx.moveTo(0, 0);
            ctx.lineTo(1, 0);
            ctx.restore();
            ctx.stroke()

            const tickInterval = 0.1;
            const tickWidth = 10;
            const tickStartY = this.yMax * this.yScale;
            const tickEndY = tickStartY + tickWidth;

            ctx.beginPath();
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            let curTickX = 0;
            while (curTickX <= 1) {
                let x = (curTickX - this.xMin) * this.xScale;
                ctx.moveTo(x, tickStartY);
                ctx.lineTo(x, tickEndY);
                ctx.fillText(curTickX.toFixed(1), x, tickEndY + 3)
                curTickX += tickInterval;
            }
            ctx.stroke();

            ctx.restore();
        },
        _drawYAxis() {
            const ctx = this.ctx;
            ctx.save();

            ctx.save();
            this._transformContext();
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, this.yMax);
            ctx.restore();
            ctx.stroke();

            const tickInterval = this._getYTickInterval();
            const tickWidth = 10;
            const tickStartX = -this.xMin * this.xScale;
            const tickEndX = tickStartX - tickWidth;

            ctx.beginPath();
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';

            let curTickY = 0;
            while (curTickY < this.yMax) {
                let y = (this.yMax - curTickY) * this.yScale;
                ctx.moveTo(tickStartX, y);
                ctx.lineTo(tickEndX, y);
                ctx.fillText(curTickY, tickEndX - 3, y + 2);
                curTickY += tickInterval;
            }
            ctx.stroke();

            ctx.restore();
        },
        _getYTickInterval() {
            const maxNumTicks = 12;

            if (this.yMax <= maxNumTicks) {
                return 1;
            }
            if (this.yMax / 5 <= maxNumTicks) {
                return 5;
            }

            let interval = 10;
            while (this.yMax / interval > maxNumTicks) {
                interval += 10;
            }
            return interval;
        }
    });
</script>
</dom-module>